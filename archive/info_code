    print("Before: ", action_index)
        #     """ IDA code starts from here"""
        #     if test_mode:
        #         """ Perform IDA"""
        #         action_index, observation_, reward, done, collision_status = expand_tree(env, config, action_index)
        #         # #print("IDA")
        #         # action = 0
        #         # while (action < config['N_actions']):
        #         #     #print(action)
        #         #     action_index_ida = action

        #         #     #t3 = time.perf_counter()
        #         #     action_angle_offset = np.deg2rad(ACTION_SPACE_STEP_ADVERSARY * action_index_ida - (int(config['N_actions']/2)*ACTION_SPACE_STEP_ADVERSARY))

        #         #     observation_, reward, done, collision_status, _ = env.step_adv1(action_angle_offset, create_leaf_node=False)
        #         #     #step_total_time += time.perf_counter() - t3

        #         #     """ Debugging code"""
        #         #     if collision_status == 1:
        #         #         #print("Action Index, collision status: ", action_index_ida, collision_status)
        #         #         #break
        #         #         action_index = action
        #         #         print("After: ", action_index)
        #         #         action += 1
        #         #         break
        #         #     else:
        #         #         action += 1
        #     #depth = input()
        #    # depth +=1
        #     depth = int(input())
        #     if depth == 2:
        #         depth = True
        #     else: depth = False
        #     print("Depth: ", depth)
        #     print("After: ", action_index)
        #     """ IDA code ends here"""
""" Binary Tree"""
                for i in range(2):
                #print("set previous environment")
                    self.env.reset_traj(node_num=start_node)
                    self.actions_taken +=1 
                    for j in range(full_tree.shape[0]):
                        action_index = full_tree[j][i]
                        #print("action index: ", action_index)
                        pos_offset = choose_action(action_index)
                        action_prob_value = action_prob(action_index)
                        observation_, reward, done, collision_status, _, position_old = self.env.step_adv1(pos_offset,action_prob_value)
                        if collision_status:
                            n_collisions+=1
                            if done_after_collision == True:
                                return observation_, reward, True, collision_status, _
                            break
                        elif done and not collision_status:
                            n_successes+=1

    def start_worker(self):
        self.thread[1] = ThreadClass(parent=None, index=1)
        self.thread[1].start()
        self.thread[1].any_signal.connect(self.testing_fun)
        self.ui.custom_btn_1.setEnabled(False)
    
    def stop_worker(self):
        self.thread[1].stop()
        self.ui.custom_btn_1.setEnabled(True)

    def start_worker_2(self):
        self.thread[2] = ThreadClass(parent=None, index=2)
        self.thread[2].start()
        self.thread[2].any_signal.connect(self.testing_fun)
        self.ui.custom_btn_3.setEnabled(False)
    
    def stop_worker_2(self):
        self.thread[2].stop()
        self.ui.custom_btn_3.setEnabled(True)


    def testing_fun(self,counter):
        cnt=counter
        index = self.sender().index
        if index==1:
            self.ui.speed_real.display(cnt)
        if index==2:
            self.ui.speed_lcd.display(cnt)

        self.ui.custom_btn_1.clicked.connect(lambda: self.start_worker())
        self.ui.custom_btn_2.clicked.connect(lambda: self.stop_worker())
        self.ui.custom_btn_3.clicked.connect(lambda: self.start_worker_2())
        self.ui.custom_btn_4.clicked.connect(lambda: self.stop_worker_2())

    def Operation(self):
        """ 
        40: complete rotation at 0.15
        time is calculated from distance and velocity"""
        # path =        [39.5, 11, 39.5, 11, 39.5,  10,   6, 39.5,  10,  11, 39.5,  11, 39.5,  10,  8,   9,   11,  39,  9, 39] # Time
        # direction =   ["r", "f",  "r", "f", "r", "r", "f",  "r", "r", "f",  "r", "f",  "r", "r", "f", "r", "f", "r", "f", "r"]   # Move forward or rotation
        # orientation = [True, -1, True,  -1,True,True,  -1, True,True,  -1, True,  -1,  True,False,-1,False, -1,True,  -1, True]

        #ros_launch_without_core()
        pass
    def affinity(X,y, plot=True):
        # https://www.science.org/doi/10.1126/science.1136800
        from sklearn.cluster import AffinityPropagation
        """ Affinity Propagation model"""
        model = AffinityPropagation(damping=0.6)
        model.fit(X)
        # assign a cluster to each example
        yhat = model.predict(X)
        # retrieve unique clusters
        clusters = unique(yhat)
        print(yhat)
        plot_clusters(X, clusters, yhat)

    def birch(X, plot=True):
        """ Balanced Iterative Reducing and Clustering using Hierarchies """
        from sklearn.cluster import Birch
        #define the model
        model = Birch(threshold=0.01, n_clusters=3)
        # fit model and predict clusters
        yhat = model.fit_predict(X, y=X[:,2])
        # retrieve unique clusters
        clusters = unique(yhat)
        print(yhat)
        plot_clusters(X,clusters,yhat)


    def DBSCAN(X,y, plot=True):
        """ Density-Based Spatial Clustering of Applications with Noise """
        from sklearn.cluster import DBSCAN
        # define the model
        model = DBSCAN(eps=0.45, min_samples=3)
        # fit model and predict clusters
        yhat = model.fit_predict(X)
        # retrieve unique clusters
        clusters = unique(yhat)
        print(yhat)
        plot_clusters(X,clusters,yhat)

    def MeanShift(X,y, plot=True):
        """ Very Expensive"""
        from sklearn.cluster import MeanShift
        # define the model
        model = MeanShift()
        # fit model and predict clusters
        yhat = model.fit_predict(X)
        # retrieve unique clusters
        clusters = unique(yhat)
        print(yhat)
        plot_clusters(X,clusters,yhat)


    def OPTICS(X,y, plot=True):
        """ Ordering Points To Identify the Clustering Structure"""
        from sklearn.cluster import OPTICS
        # define the model
        model = OPTICS(eps=0.8, min_samples=30)
        # fit model and predict clusters
        yhat = model.fit_predict(X)
        # retrieve unique clusters
        clusters = unique(yhat)
        print(yhat)
        plot_clusters(X,clusters,yhat)

    def SpectralClustering(X,y, plot=True):
        from sklearn.cluster import SpectralClustering
        # define the model
        model = SpectralClustering(n_clusters=2,affinity='nearest_neighbors')
        # fit model and predict clusters
        yhat = model.fit_predict(X)
        # retrieve unique clusters
        clusters = unique(yhat)
        print(yhat)
        plot_clusters(X,clusters,yhat)
def create_model():
    model = []
    #model.append(AffinityPropagation)
    return model[0]

def plot_clusters(X, clusters, yhat):
    # create scatter plot for samples from each cluster
    for cluster in clusters:
        # get row indexes for samples with this cluster
        row_ix = where(yhat == cluster)
        # create scatter of these samples
        pyplot.scatter(X[row_ix, 1], X[row_ix, 2])
    # show the plot
    pyplot.show()

def affinity(X,y, plot=True):
    # https://www.science.org/doi/10.1126/science.1136800
    from sklearn.cluster import AffinityPropagation
    """ Affinity Propagation model"""
    model = AffinityPropagation(damping=0.6)
    model.fit(X)
    # assign a cluster to each example
    yhat = model.predict(X)
    # retrieve unique clusters
    clusters = unique(yhat)
    print(yhat)
    plot_clusters(X, clusters, yhat)
    
def agglomerative(X,y, plot=True):
    #https://en.wikipedia.org/wiki/Hierarchical_clustering
    from sklearn.cluster import AgglomerativeClustering
    # define the model
    model = AgglomerativeClustering(n_clusters=2)
    # fit model and predict clusters
    yhat = model.fit_predict(X)
    # retrieve unique clusters
    clusters = unique(yhat)
    print(yhat)
    plot_clusters(X,clusters,yhat)

def birch(X, plot=True):
    """ Balanced Iterative Reducing and Clustering using Hierarchies """
    from sklearn.cluster import Birch
    #define the model
    model = Birch(threshold=0.01, n_clusters=3)
    # fit model and predict clusters
    yhat = model.fit_predict(X, y=X[:,2])
    # retrieve unique clusters
    clusters = unique(yhat)
    print(yhat)
    plot_clusters(X,clusters,yhat)


def DBSCAN(X,y, plot=True):
    """ Density-Based Spatial Clustering of Applications with Noise """
    from sklearn.cluster import DBSCAN
    # define the model
    model = DBSCAN(eps=0.45, min_samples=3)
    # fit model and predict clusters
    yhat = model.fit_predict(X)
    # retrieve unique clusters
    clusters = unique(yhat)
    print(yhat)
    plot_clusters(X,clusters,yhat)


def K_Means(X,y, plot=True):
    # define the model
    from sklearn.cluster import KMeans
    model = KMeans(n_clusters=2, n_init=100)
    # fit model and predict clusters
    yhat = model.fit_predict(X)  #, sample_weight=X[:,-1]
    # retrieve unique clusters
    clusters = unique(yhat)
    print(yhat)
    plot_clusters(X,clusters,yhat)

def MiniBatch_KMeans(X,y, plot=True):
    from sklearn.cluster import MiniBatchKMeans

    # define the model
    model = MiniBatchKMeans(n_clusters=3)
    # fit model and predict clusters
    yhat = model.fit_predict(X)
    # retrieve unique clusters
    clusters = unique(yhat)
    print(yhat)
    plot_clusters(X,clusters,yhat)

def MeanShift(X,y, plot=True):
    """ Very Expensive"""
    from sklearn.cluster import MeanShift
    # define the model
    model = MeanShift()
    # fit model and predict clusters
    yhat = model.fit_predict(X)
    # retrieve unique clusters
    clusters = unique(yhat)
    print(yhat)
    plot_clusters(X,clusters,yhat)


def OPTICS(X,y, plot=True):
    """ Ordering Points To Identify the Clustering Structure"""
    from sklearn.cluster import OPTICS
    # define the model
    model = OPTICS(eps=0.8, min_samples=30)
    # fit model and predict clusters
    yhat = model.fit_predict(X)
    # retrieve unique clusters
    clusters = unique(yhat)
    print(yhat)
    plot_clusters(X,clusters,yhat)

def SpectralClustering(X,y, plot=True):
    from sklearn.cluster import SpectralClustering
    # define the model
    model = SpectralClustering(n_clusters=2,affinity='nearest_neighbors')
    # fit model and predict clusters
    yhat = model.fit_predict(X)
    # retrieve unique clusters
    clusters = unique(yhat)
    print(yhat)
    plot_clusters(X,clusters,yhat)

def MixtureofGaussians(X,y, plot=True):
    from sklearn.mixture import BayesianGaussianMixture
    # define the model
    model = BayesianGaussianMixture(n_components=3,covariance_type='tied',weight_concentration_prior_type='dirichlet_distribution', init_params='kmeans')
    # fit model and predict clusters
    yhat = model.fit_predict(X)
    print(yhat)
    # retrieve unique clusters
    clusters = unique(yhat)

    plot_clusters(X,clusters,yhat)

def plot_3d(X):
    from mpl_toolkits import mplot3d
    import matplotlib.pyplot as plt
    fig = plt.figure()
    # syntax for 3-D projection
    ax = plt.axes(projection ='3d')

    # # create scatter plot for samples from each class
    # for class_value in [0,0.36]:
    #     # get row indexes for samples with this class
    #     row_ix = where(X[:,2] >= class_value)
    #     # create scatter of these samples
    #     ax.scatter(X[row_ix, 0], X[row_ix, 1], X[row_ix, 2])
    
    # plotting
    ax.scatter(X[:,0], X[:,1], X[:,2], marker='^')
    ax.set_title('Distance, Nodes, Prob. collision')
    plt.show()
